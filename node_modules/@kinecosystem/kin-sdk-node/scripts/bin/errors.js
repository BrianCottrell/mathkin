"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("./blockchain/errors");
class ErrorUtils {
    static getTransaction(errorBody) {
        if (errorBody && errorBody.extras && errorBody.extras.result_codes.transaction) {
            return errorBody.extras.result_codes.transaction;
        }
        return undefined;
    }
    static getOperations(errorBody) {
        if (errorBody && errorBody.extras && errorBody.extras.result_codes.operations) {
            return errorBody.extras.result_codes.operations;
        }
        return undefined;
    }
}
class HorizonError extends Error {
    constructor(msg, errorBody, title) {
        super(`${msg}, error code: ${errorBody.status} ` + ((title ? `title: ${errorBody.title}` : "")));
        this.msg = msg;
        this.errorBody = errorBody;
        this.title = title;
        this.type = 'HorizonError';
        this.errorCode = errorBody.status;
        this.errorBody = errorBody;
        this._resultTransactionCode = ErrorUtils.getTransaction(errorBody);
        this._resultOperationsCode = ErrorUtils.getOperations(errorBody);
    }
    get resultTransactionCode() {
        return this._resultTransactionCode;
    }
    get resultOperationsCode() {
        return this._resultOperationsCode;
    }
}
exports.HorizonError = HorizonError;
class AccountNotFoundError extends HorizonError {
    constructor(errorBody, title) {
        super(`Account was not found in the network.`, errorBody, title);
        this.errorBody = errorBody;
        this.title = title;
        this.type = 'AccountNotFoundError';
        this.errorCode = 404;
    }
}
exports.AccountNotFoundError = AccountNotFoundError;
class NetworkError extends Error {
    constructor(error) {
        super(error && error.message ? error.message : `Network error occurred`);
        this.error = error;
        this.type = 'NetworkError';
        this.error = error;
    }
}
exports.NetworkError = NetworkError;
class NetworkMismatchedError extends Error {
    constructor(message) {
        super(message);
        this.type = 'NetworkMismatchedError';
    }
}
exports.NetworkMismatchedError = NetworkMismatchedError;
class InvalidDataError extends Error {
    constructor() {
        super(`Unable to sign whitelist transaction, invalid data`);
        this.type = 'InvalidDataError';
    }
}
exports.InvalidDataError = InvalidDataError;
class ServerError extends HorizonError {
    constructor(errorBody) {
        super(`Server error`, errorBody);
        this.errorBody = errorBody;
        this.type = 'ServerError';
    }
}
exports.ServerError = ServerError;
class FriendbotError extends Error {
    constructor(errorCode, extra, msg) {
        super(`Friendbot error, ` + (errorCode ? `error code: ${errorCode} ` : "") + (msg ? `msg: ${msg}` : ""));
        this.errorCode = errorCode;
        this.extra = extra;
        this.msg = msg;
        this.type = 'FriendbotError';
        this.errorCode = errorCode;
        this.extra = extra;
    }
}
exports.FriendbotError = FriendbotError;
class InvalidAddressError extends Error {
    constructor() {
        super('Invalid wallet address.');
        this.type = 'InvalidAddressError';
    }
}
exports.InvalidAddressError = InvalidAddressError;
class ChannelBusyError extends Error {
    constructor() {
        super('Cannot acquire a free channel.');
        this.type = 'ChannelBusyError';
    }
}
exports.ChannelBusyError = ChannelBusyError;
class BadRequestError extends HorizonError {
    constructor(errorBody, title) {
        super(`Bad Request error`, errorBody, title);
        this.errorBody = errorBody;
        this.title = title;
        this.type = 'BadRequestError';
    }
}
exports.BadRequestError = BadRequestError;
class InternalError extends HorizonError {
    constructor(errorBody, title) {
        super(`Internal error`, errorBody, title ? title : "{'internal_error': 'unknown horizon error'}");
        this.errorBody = errorBody;
        this.title = title;
        this.type = 'InternalError';
    }
}
exports.InternalError = InternalError;
class AccountExistsError extends HorizonError {
    constructor(errorBody, title) {
        super(`Account already exists`, errorBody, title);
        this.errorBody = errorBody;
        this.title = title;
        this.type = 'AccountExistsError';
    }
}
exports.AccountExistsError = AccountExistsError;
class LowBalanceError extends HorizonError {
    constructor(errorBody, title) {
        super(`Low balance`, errorBody, title);
        this.errorBody = errorBody;
        this.title = title;
        this.type = 'LowBalanceError';
    }
}
exports.LowBalanceError = LowBalanceError;
class AccountNotActivatedError extends HorizonError {
    constructor(errorBody, title) {
        super(`Account not activated`, errorBody, title);
        this.errorBody = errorBody;
        this.title = title;
        this.type = 'AccountNotActivatedError';
    }
}
exports.AccountNotActivatedError = AccountNotActivatedError;
class ResourceNotFoundError extends HorizonError {
    constructor(errorBody, title) {
        super(`Resources not found`, errorBody, title);
        this.errorBody = errorBody;
        this.title = title;
        this.type = 'ResourceNotFoundError';
    }
}
exports.ResourceNotFoundError = ResourceNotFoundError;
class ErrorDecoder {
    static translate(errorBody) {
        if (errorBody && errorBody.response) {
            errorBody = errorBody.response;
            if (errorBody.data) {
                errorBody = errorBody.data;
            }
            if (errorBody.type && errorBody.status) {
                if (errorBody.type.includes(errors_1.HorizonErrorList.TRANSACTION_FAILED)) {
                    return this.translateTransactionError(errorBody.status, errorBody);
                }
                else {
                    return this.translateHorizonError(errorBody.status, errorBody);
                }
            }
            else {
                return new InternalError(errorBody);
            }
        }
        return new NetworkError(errorBody);
    }
    static translateOperationError(errorCode, errorBody) {
        let resultCode;
        const resultOperationsCode = ErrorUtils.getOperations(errorBody);
        if (resultOperationsCode === undefined || !resultOperationsCode.length) {
            return new InternalError(errorBody);
        }
        for (let entry of resultOperationsCode) {
            if (entry !== errors_1.OperationResultCode.SUCCESS) {
                resultCode = entry;
                break;
            }
        }
        if (!resultCode) {
            return new InternalError(errorBody);
        }
        if (this.includesObject(resultCode, [errors_1.OperationResultCode.BAD_AUTH,
            errors_1.CreateAccountResultCode.MALFORMED,
            errors_1.PaymentResultCode.NO_ISSUER,
            errors_1.PaymentResultCode.LINE_FULL,
            errors_1.ChangeTrustResultCode.INVALID_LIMIT])) {
            return new BadRequestError(errorBody);
        }
        else if (this.includesObject(resultCode, [errors_1.OperationResultCode.NO_ACCOUNT,
            errors_1.PaymentResultCode.NO_DESTINATION])) {
            return new AccountNotFoundError(errorBody);
        }
        else if (resultCode === errors_1.CreateAccountResultCode.ACCOUNT_EXISTS) {
            return new AccountExistsError(errorBody);
        }
        else if (this.includesObject(resultCode, [errors_1.CreateAccountResultCode.LOW_RESERVE, errors_1.PaymentResultCode.UNDERFUNDED])) {
            return new LowBalanceError(errorBody);
        }
        else if (this.includesObject(resultCode, [errors_1.PaymentResultCode.SRC_NO_TRUST,
            errors_1.PaymentResultCode.NO_TRUST,
            errors_1.PaymentResultCode.SRC_NOT_AUTHORIZED,
            errors_1.PaymentResultCode.NOT_AUTHORIZED])) {
            return new AccountNotActivatedError(errorBody);
        }
        return new InternalError(errorBody);
    }
    static translateTransactionError(errorCode, errorBody) {
        const resultTransactionCode = ErrorUtils.getTransaction(errorBody);
        if (resultTransactionCode === errors_1.TransactionErrorList.FAILED) {
            return this.translateOperationError(errorCode, errorBody);
        }
        else if (resultTransactionCode === errors_1.TransactionErrorList.NO_ACCOUNT) {
            return new AccountNotFoundError(errorBody);
        }
        else if (resultTransactionCode === errors_1.TransactionErrorList.INSUFFICIENT_BALANCE) {
            return new LowBalanceError(errorBody);
        }
        else if (resultTransactionCode) {
            return new BadRequestError(errorBody);
        }
        return new InternalError(errorBody);
    }
    static translateHorizonError(errorCode, errorBody) {
        if (this.includesObject(errorBody.type, [errors_1.HorizonErrorList.RATE_LIMIT_EXCEEDED, errors_1.HorizonErrorList.SERVER_OVER_CAPACITY, errors_1.HorizonErrorList.TIMEOUT])) {
            return new ServerError(errorBody);
        }
        else if (this.includesObject(errorBody.type, [errors_1.HorizonErrorList.NOT_FOUND])) {
            return new ResourceNotFoundError(errorBody);
        }
        else if (this.includesObject(errorBody.type, [errors_1.HorizonErrorList.INTERNAL_SERVER_ERROR])) {
            return new InternalError(errorBody);
        }
        else if (this.includesObject(errorBody.type, Object.values(errors_1.HorizonErrorList))) {
            return new BadRequestError(errorBody);
        }
        return new InternalError(errorCode);
    }
    static includesObject(type, list) {
        for (let entry of list) {
            if (type.includes(entry)) {
                return true;
            }
        }
        return false;
    }
}
exports.ErrorDecoder = ErrorDecoder;
//# sourceMappingURL=errors.js.map