"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const kin_sdk_1 = require("@kinecosystem/kin-sdk");
const transactionBuilder_1 = require("./transactionBuilder");
const errors_1 = require("../errors");
const config_1 = require("../config");
const errors_2 = require("./errors");
class TxSender {
    constructor(_keypair, _appId, _server, _blockchainInfoRetriever) {
        this._keypair = _keypair;
        this._appId = _appId;
        this._server = _server;
        this._blockchainInfoRetriever = _blockchainInfoRetriever;
        this._keypair = _keypair;
        this._appId = _appId;
        this._server = _server;
        this._blockchainInfoRetriever = _blockchainInfoRetriever;
    }
    get appId() {
        return this._appId;
    }
    getTransactionBuilder(txFee, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.loadSenderAccountData(channel);
            return new transactionBuilder_1.TransactionBuilder(response, { fee: txFee, appId: this.appId }, channel)
                .setTimeout(0);
        });
    }
    buildCreateAccount(address, startingBalance, fee, memo, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            const builder = yield this.getTransactionBuilder(fee, channel);
            if (memo) {
                builder.addTextMemo(memo);
            }
            builder.addOperation(kin_sdk_1.Operation.createAccount({
                source: this._keypair.publicAddress,
                destination: address,
                startingBalance: startingBalance.toString()
            }));
            return builder;
        });
    }
    buildSendKin(address, amount, fee, memo, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            const builder = yield this.getTransactionBuilder(fee, channel);
            if (memo) {
                builder.addTextMemo(memo);
            }
            builder.addOperation(kin_sdk_1.Operation.payment({
                source: this._keypair.publicAddress,
                destination: address,
                asset: kin_sdk_1.Asset.native(),
                amount: amount.toString()
            }));
            return builder;
        });
    }
    submitTransaction(builder) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const tx = builder.build();
                const signers = new Array();
                signers.push(kin_sdk_1.Keypair.fromSecret(this._keypair.seed));
                if (builder.channel) {
                    signers.push(kin_sdk_1.Keypair.fromSecret(builder.channel.keyPair.seed));
                }
                tx.sign(...signers);
                const transactionResponse = yield this._server.submitTransaction(tx);
                return transactionResponse.hash;
            }
            catch (e) {
                const error = errors_1.ErrorDecoder.translate(e);
                if (this.checkForInsufficientChannelFeeBalance(builder, error)) {
                    yield this.topUpChannel(builder);
                    return this.submitTransaction(builder);
                }
                else {
                    throw error;
                }
            }
        });
    }
    whitelistTransaction(payload) {
        let txPair;
        if (typeof payload === "string") {
            const tx = JSON.parse(payload);
            if (tx.envelop != null) {
                txPair = tx;
                txPair.envelope = txPair.envelop;
            }
            else {
                txPair = tx;
            }
        }
        else {
            txPair = payload;
        }
        if (typeof txPair.envelope !== "string") {
            throw new TypeError("'envelope' must be type of string");
        }
        const networkPassphrase = kin_sdk_1.Network.current().networkPassphrase();
        if (networkPassphrase !== txPair.networkId) {
            throw new errors_1.NetworkMismatchedError("Unable to sign whitelist transaction, network type is mismatched");
        }
        const transaction = new kin_sdk_1.Transaction(txPair.envelope);
        transaction.sign(kin_sdk_1.Keypair.fromSecret(this._keypair.seed));
        const envelope = transaction.toEnvelope();
        const buffer = envelope.toXDR("base64");
        return buffer.toString();
    }
    checkForInsufficientChannelFeeBalance(builder, error) {
        if (!builder.channel) {
            return false;
        }
        return error.resultTransactionCode === errors_2.TransactionErrorList.INSUFFICIENT_BALANCE;
    }
    topUpChannel(builder) {
        return __awaiter(this, void 0, void 0, function* () {
            const channel = builder.channel;
            const fee = yield this._blockchainInfoRetriever.getMinimumFee();
            const amount = fee * config_1.CHANNEL_TOP_UP_TX_COUNT;
            const topUpBuilder = yield this.buildSendKin(channel.keyPair.publicAddress, amount, fee);
            yield this.submitTransaction(topUpBuilder);
        });
    }
    loadSenderAccountData(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            const addressToLoad = channel ? channel.keyPair.publicAddress : this._keypair.publicAddress;
            const response = yield this._server.loadAccount(addressToLoad);
            return response;
        });
    }
}
exports.TxSender = TxSender;
//# sourceMappingURL=txSender.js.map