"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const kin_sdk_1 = require("@kinecosystem/kin-sdk");
const errors_1 = require("../errors");
class TransactionRetriever {
    constructor(_server) {
        this._server = _server;
        this.DEFAULT_ORDER = "desc";
        this.DEFAULT_LIMIT = 10;
        this._server = _server;
    }
    fetchTransaction(transactionId, simplified) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const transactionRecord = yield this._server.transactions().transaction(transactionId).call();
                return TransactionRetriever.fromStellarTransaction(transactionRecord, simplified);
            }
            catch (e) {
                throw errors_1.ErrorDecoder.translate(e);
            }
        });
    }
    fetchTransactionHistory(params, simplified) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const transactionCallBuilder = this._server.transactions().forAccount(params.address)
                    .limit(params.limit ? params.limit : this.DEFAULT_LIMIT)
                    .order(params.order ? params.order : this.DEFAULT_ORDER);
                if (params.cursor) {
                    transactionCallBuilder.cursor(params.cursor);
                }
                const transactionRecords = yield transactionCallBuilder.call();
                const transactionHistory = new Array();
                for (const record of transactionRecords.records) {
                    transactionHistory.push(TransactionRetriever.fromStellarTransaction(record, simplified));
                }
                return transactionHistory;
            }
            catch (e) {
                throw errors_1.ErrorDecoder.translate(e);
            }
        });
    }
    static fromStellarTransaction(transactionRecord, simplified) {
        const xdrTransaction = new kin_sdk_1.Transaction(transactionRecord.envelope_xdr);
        const operations = xdrTransaction.operations;
        const transactionBase = {
            fee: xdrTransaction.fee,
            hash: transactionRecord.hash,
            sequence: parseInt(transactionRecord.source_account_sequence),
            signatures: xdrTransaction.signatures,
            source: transactionRecord.source_account,
            timestamp: transactionRecord.created_at,
            type: "RawTransaction"
        };
        if (simplified !== false) {
            if (operations.length === 1) {
                const operation = operations[0];
                if (operation.type === "payment") {
                    return Object.assign({}, transactionBase, { source: operation.source ? operation.source : transactionRecord.source_account, destination: operation.destination, amount: parseFloat(operation.amount), memo: transactionRecord.memo, type: "PaymentTransaction" });
                }
                else if (operation.type === "createAccount") {
                    return Object.assign({}, transactionBase, { source: operation.source ? operation.source : transactionRecord.source_account, destination: operation.destination, startingBalance: parseFloat(operation.startingBalance), memo: transactionRecord.memo, type: "CreateAccountTransaction" });
                }
            }
        }
        return Object.assign({}, transactionBase, { memo: xdrTransaction.memo, operations: xdrTransaction.operations });
    }
    static fromTransactionPayload(envelope, networkId, simplified) {
        const transactionRecord = new kin_sdk_1.Transaction(envelope);
        const transactionBase = {
            fee: transactionRecord.fee,
            hash: transactionRecord.hash().toString("base64"),
            sequence: parseInt(String(transactionRecord.sequence)),
            signatures: transactionRecord.signatures,
            source: transactionRecord.source,
            timestamp: undefined,
            type: "RawTransaction"
        };
        const networkPassphrase = kin_sdk_1.Network.current().networkPassphrase();
        if (networkPassphrase !== networkId) {
            throw new errors_1.NetworkMismatchedError(`Unable to decode transaction, network type is mismatched`);
        }
        if (simplified !== false) {
            if (transactionRecord.operations.length === 1) {
                const operation = transactionRecord.operations[0];
                if (operation.type === "payment") {
                    return Object.assign({}, transactionBase, { source: operation.source ? operation.source : transactionRecord.source, destination: operation.destination, amount: parseFloat(operation.amount), memo: transactionRecord.memo.value, type: "PaymentTransaction" });
                }
                else if (operation.type === "createAccount") {
                    return Object.assign({}, transactionBase, { source: operation.source ? operation.source : transactionRecord.source, destination: operation.destination, startingBalance: parseFloat(operation.startingBalance), memo: transactionRecord.memo.value, type: "CreateAccountTransaction" });
                }
            }
        }
        return Object.assign({}, transactionBase, { memo: transactionRecord.memo, operations: transactionRecord.operations });
    }
}
exports.TransactionRetriever = TransactionRetriever;
//# sourceMappingURL=transactionRetriever.js.map