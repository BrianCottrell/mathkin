"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const keyPair_1 = require("./keyPair");
const crypto = require("crypto");
const txSender_1 = require("./txSender");
const kin_sdk_1 = require("@kinecosystem/kin-sdk");
const accountDataRetriever_1 = require("./accountDataRetriever");
const blockchainInfoRetriever_1 = require("./blockchainInfoRetriever");
var Channels;
(function (Channels) {
    function createChannels(params) {
        const server = new kin_sdk_1.Server(params.environment.url);
        kin_sdk_1.Network.use(new kin_sdk_1.Network(params.environment.passphrase));
        const accountDataRetriever = new accountDataRetriever_1.AccountDataRetriever(server);
        const blockchainInfoRetriever = new blockchainInfoRetriever_1.BlockchainInfoRetriever(server);
        const txSender = new txSender_1.TxSender(keyPair_1.KeyPair.fromSeed(params.baseSeed), "", server, blockchainInfoRetriever);
        return new ChannelsGenerator(txSender, accountDataRetriever, blockchainInfoRetriever)
            .createChannels(params.baseSeed, params.salt, params.channelsCount, params.startingBalance);
    }
    Channels.createChannels = createChannels;
    function generateSeeds(params) {
        return ChannelsGenerator.generateSeeds(params);
    }
    Channels.generateSeeds = generateSeeds;
})(Channels = exports.Channels || (exports.Channels = {}));
class ChannelsGenerator {
    constructor(_txSender, _accountDataRetriever, _blockchainInfoRetriever) {
        this._txSender = _txSender;
        this._accountDataRetriever = _accountDataRetriever;
        this._blockchainInfoRetriever = _blockchainInfoRetriever;
        this._txSender = _txSender;
        this._blockchainInfoRetriever = _blockchainInfoRetriever;
        this._accountDataRetriever = _accountDataRetriever;
    }
    static generateSeeds(params) {
        if (params.channelsCount > this.CHANNELS_COUNT_LIMIT) {
            throw new RangeError(`channelsCount' can be up to ${this.CHANNELS_COUNT_LIMIT}`);
        }
        const hashedSalt = crypto.createHash('sha256').update(params.salt).digest('hex');
        const keyPairs = [];
        for (let i = 0; i < params.channelsCount; i++) {
            let keyPair = keyPair_1.KeyPair.generateHDSeed(params.baseSeed, hashedSalt + i);
            keyPairs.push(keyPair);
        }
        return keyPairs;
    }
    createChannels(baseSeed, salt, channelsCount, startingBalance) {
        return __awaiter(this, void 0, void 0, function* () {
            const channels = ChannelsGenerator.generateSeeds({
                baseSeed: baseSeed,
                salt: salt,
                channelsCount: channelsCount
            });
            const minimumFee = yield this._blockchainInfoRetriever.getMinimumFee();
            const builder = yield this._txSender.getTransactionBuilder(minimumFee);
            let shouldSendTx = false;
            const firstExists = yield this._accountDataRetriever.isAccountExisting(channels[0].publicAddress);
            const lastExists = yield this._accountDataRetriever.isAccountExisting(channels[channels.length - 1].publicAddress);
            if (firstExists && lastExists)
                return channels;
            for (const channel of channels) {
                if ((!firstExists && !lastExists) ||
                    !(yield this._accountDataRetriever.isAccountExisting(channel.publicAddress))) {
                    shouldSendTx = true;
                    builder.addOperation(kin_sdk_1.Operation.createAccount({
                        destination: channel.publicAddress,
                        startingBalance: startingBalance.toString()
                    }));
                }
            }
            if (shouldSendTx) {
                yield this._txSender.submitTransaction(builder);
            }
            return channels;
        });
    }
}
ChannelsGenerator.CHANNELS_COUNT_LIMIT = 100;
exports.ChannelsGenerator = ChannelsGenerator;
//# sourceMappingURL=channelsGenerator.js.map