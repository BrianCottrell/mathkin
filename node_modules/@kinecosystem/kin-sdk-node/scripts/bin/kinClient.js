"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const kinAccount_1 = require("./kinAccount");
const kin_sdk_1 = require("@kinecosystem/kin-sdk");
const accountDataRetriever_1 = require("./blockchain/accountDataRetriever");
const friendbot_1 = require("./friendbot");
const blockchainInfoRetriever_1 = require("./blockchain/blockchainInfoRetriever");
const transactionRetriever_1 = require("./blockchain/transactionRetriever");
const blockchainListeners_1 = require("./blockchain/blockchainListeners");
const config_1 = require("./config");
class KinClient {
    constructor(_environment) {
        this._environment = _environment;
        this._environment = _environment;
        this._server = new kin_sdk_1.Server(_environment.url, { allowHttp: false, headers: config_1.GLOBAL_HEADERS, retry: config_1.GLOBAL_RETRY });
        kin_sdk_1.Network.use(new kin_sdk_1.Network(_environment.passphrase));
        this._accountDataRetriever = new accountDataRetriever_1.AccountDataRetriever(this._server);
        this._friendbotHandler = _environment.friendbotUrl ? new friendbot_1.Friendbot(_environment.friendbotUrl, this._accountDataRetriever) : undefined;
        this._blockchainInfoRetriever = new blockchainInfoRetriever_1.BlockchainInfoRetriever(this._server);
        this._transactionRetriever = new transactionRetriever_1.TransactionRetriever(this._server);
        this._blockchainListener = new blockchainListeners_1.BlockchainListener(this._server);
    }
    get environment() {
        return this._environment;
    }
    createKinAccount(params) {
        return new kinAccount_1.KinAccount(params.seed, this._accountDataRetriever, this._server, this._blockchainInfoRetriever, params.appId ? params.appId : config_1.ANON_APP_ID, params.channelSecretKeys);
    }
    getMinimumFee() {
        return this._blockchainInfoRetriever.getMinimumFee();
    }
    getAccountBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._accountDataRetriever.fetchKinBalance(address);
        });
    }
    isAccountExisting(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._accountDataRetriever.isAccountExisting(address);
        });
    }
    getAccountData(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._accountDataRetriever.fetchAccountData(address);
        });
    }
    getTransactionData(transactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._transactionRetriever.fetchTransaction(transactionId);
        });
    }
    getRawTransactionData(transactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._transactionRetriever.fetchTransaction(transactionId, false);
        });
    }
    getTransactionHistory(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._transactionRetriever.fetchTransactionHistory(params);
        });
    }
    getRawTransactionHistory(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._transactionRetriever.fetchTransactionHistory(params, false);
        });
    }
    createPaymentListener(params) {
        return this._blockchainListener.createPaymentsListener(params.onPayment, params.addresses);
    }
    friendbot(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._friendbotHandler) {
                throw Error("Friendbot url not defined, friendbot is not available on production environment");
            }
            return this._friendbotHandler.createOrFund(params.address, params.amount);
        });
    }
}
exports.KinClient = KinClient;
//# sourceMappingURL=kinClient.js.map